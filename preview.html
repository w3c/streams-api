<!DOCTYPE html>

<html>

<head>
	<title>Streams API (Preview version)</title>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">

	<!-- <script class=remove src="http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js"></script> -->
	<script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c-common"></script>
	<!-- <script class="remove" src="respec-w3c-common.js"></script> -->

	<script class="remove">
var respecConfig = {
	// specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
	specStatus:           "ED",

	// the specification's short name, as in http://www.w3.org/TR/short-name/
	shortName:            "streams-api",

	// if your specification has a subtitle that goes below the main
	// formal title, define it here
	// subtitle   :  "an excellent document",

	// if you wish the publication date to be other than today, set this
	// publishDate:  "yyyy-mm-dd",

	// if the specification's copyright date is a range of years, specify
	// the start date here:
	// copyrightStart: "2005"

	// if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
	// and its maturity status
	// previousPublishDate:  "yyyy-mm-dd",
	// previousMaturity:  "WD",

	// if there a publicly available Editor's Draft, this is the link
	edDraftURI:           "http://dvcs.w3.org/hg/streams-api/raw-file/tip/Overview.htm",

	// if this is a LCWD, uncomment and set the end of its review period
	// lcEnd: "2009-08-05",

	// if you want to have extra CSS, append them to this list
	// it is recommended that the respec.css stylesheet be kept
	//extraCSS:             ["http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
	//	"http://www.w3.org/StyleSheets/TR/W3C-ED.css",
	//	],

	// editors, add as many as you like
	// only "name" is required

	localBiblio: {
		"EncodingDetermination": {
			title: "Encoding",
			href: "http://encoding.spec.whatwg.org/",
			authors: ["Anne van Kesteren", "Joshua Bell"],
			publisher: "WHATWG"
		}
	},

	editors:  [
		{ name: "Feras Moussa", url: "mailto:feras.moussa@hotmail.com",
			company: "Invited Expert",  },
		{ name: "Takeshi Yoshino", url: "mailto:tyoshino@google.com",
			company: "Google, Inc.",  },
	],

	// authors, add as many as you like.
	// This is optional, uncomment if you have authors as well as editors.
	// only "name" is required. Same format as editors.

	//authors:  [
	//    { name: "Your Name", url: "http://example.org/",
	//      company: "Your Company", companyURL: "http://example.com/" },
	//],

	// name of the WG
	wg:           "W3C Web Applications (WebApps)",

	// URI of the public WG page
	wgURI:        "http://www.w3.org/2008/webapps/",

	// name (with the @w3c.org) of the public mailing to which comments are due
	wgPublicList: "public-webapps",

	// URI of the patent status for this WG, for Rec-track documents
	// !!!! IMPORTANT !!!!
	// This is important for Rec-track documents, do not copy a patent URI from a random
	// document unless you know what you're doing. If in doubt ask your friendly neighbourhood
	// Team Contact.
	wgPatentURI:  "",
};
</script>

	<!-- Styles to mimic File API spec -->
	<!-- <style type="text/css"> -->
	<!-- 	table.error { border-collapse:collapse; border-style:hidden hidden none hidden } -->
	<!-- 	table.error thead { border-bottom:solid } -->
	<!-- 	table.error tbody th:first-child { border-left:solid } -->
	<!-- 	table.error td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em } -->
	<!-- </style> -->

</head>
<body>

	<section id="sotd">
		<p>
			This document is not complete.
			It is subject to major changes and, while early experimentations are encouraged, it is therefore not intended for implementation.
		</p>

		<p>
			To check recent changes and rationale for them, please visit <a href="https://dvcs.w3.org/hg/streams-api/">Mercurial history</a>.
			Check open bugs at Bugzilla using <a href="https://www.w3.org/Bugs/Public/buglist.cgi?component=Streams%20API">this link</a>.
			If you wish to submit a bug, please use <a href="https://www.w3.org/Bugs/Public/enter_bug.cgi?product=WebAppsWG&component=Streams%20API">this link</a>.
			All comments and bug reports are welcome.
		</p>
	</section>

	<section id="abstract">
		<!-- TODO: are all of the links and objects in the abstract formatted? -->
		<p>
			This specification provides an API for representing byte stream in web applications, as well as programmatically building and reading its contents.
			This includes:
		</p>
		<ul>
			<li>
				A <a>WritableByteStream</a> interface which defines a protocol for data consuming APIs to communicate with other data producing APIs or code.
			</li>
			<li>
				A <a>ReadableByteStream</a> interface which defines a protocol for data producing APIs to communicate with other data consuming APIs or code.
			</li>
			<li>
				A <a>ByteStream</a> interface which represents a byte sequence which can be read only once and provides APIs for building it, writing data to it, reading and piping data from it.
			</li>
			<li>
				A <a>ByteStreamReadResult</a> interface which represents the result of consuming operations such as reading and piping.
				It holds a chunk of content read from a stream, the number of bytes consumed, and EOF signal.
			</li>
			<li>
				A <a>ByteStreamReadType</a> enum which represents data types as which the <a>ReadableByteStream</a> can be read.
			</li>
			<li>
				A list of notable byte stream <a href="#producers">producers</a> and <a href="#consumers">consumers</a> for which we can apply either or both of <a>ReadableByteStream</a> and <a>WritableByteStream</a> model.
			</li>
			<li>
				Extensions to <a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#the-xmlhttprequest-interface">XMLHttpRequest</a> [[!XMLHTTPREQUEST2]] to add support for uploading data via <a>WritableByteStream</a> and downloading a response as a <a>ReadableByteStream</a>.
			</li>
			<li>
				Extensions to <a href="http://dev.w3.org/2006/webapi/FileAPI/#dfn-createObjectURL">URL.createObjectURL</a> and
				<a href="http://dev.w3.org/2006/webapi/FileAPI/#dfn-revokeObjectURL">URL.revokeObjectURL</a> to add support for <a>ReadableByteStream</a>.
			</li>
		</ul>

		<p>
			This API is designed to be used in conjunction with other APIs and elements on the web platform, notably:
			<a href="http://dev.w3.org/2006/webapi/FileAPI">File</a> [[!FILE-API]],
			<a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2">XMLHttpRequest</a>
			(e.g. with an overloaded <a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#the-send-method"><code>send()</code></a> method
			and <a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#the-responsetype-attribute"><code>response</code></a> object for <a>ByteStream</a> objects) [[!XMLHTTPREQUEST2]],
			<a href="http://dev.w3.org/html5/postmsg/#dom-window-postmessage"><code>postMessage</code></a>, and
			Web Workers [[!WEBWORKERS]].
		</p>
	</section>

	<section id="introduction" class="section informative">
		<h2>Introduction</h2>

		<p>
			Web applications should have the ability to acquire and manipulate data in a wide variety of forms, including as a sequence of data made available over time.
			This specification defines the basic representation for byte streams, and programmatic ways to create, read, and write to byte streams and errors raised on those operations.
		</p>

		<p>
			The <a>WritableByteStream</a> interface defines a protocol for data consuming APIs to communicate with other data producing APIs or code.
			It provides a <code>write</code> method for writing data to a <a>WritableByteStream</a> as a <a>Blob</a>, <a>ArrayBufferView</a>, or <a>DOMString</a>, and should happen asynchronously on the user agent’s main thread.
		</p>

		<p>
			The <a>ReadableByteStream</a> interface defines a protocol for data producing APIs to communicate with other data consuming APIs or code.
			It provides a <code>read</code> method for reading data
			from a <a>ReadableByteStream</a> as a <a>ByteStreamReadResult</a>, which provides the data as a <a>Blob</a>, <a>ArrayBufferView</a>, or <a>DOMString</a>,
			and should happen asynchronously on the user agent’s main thread. Additionally, the stream can also be used in API <a href="#consumers">consumers</a> such as a media element.
		</p>

		<p>
			The <a>ByteStream</a> interface represents binary data which can be obtained over time and read once. A <a>ByteStream</a> can come from API <a href="#producers">producers</a> such as <a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#the-xmlhttprequest-interface"><code>XMLHttpRequest</code></a>, or can
			be built using the <a>ByteStream</a> constructor.
			Producer APIs themselves can implement the <a>ReadableByteStream</a> interface.
		</p>

		<p>
			An asynchronous API for reading <a>ReadableByteStream</a>s prevents blocking and UI "freezing" on a user agent’s main thread
			This specification defines an asynchronous API to access a <a>ByteStream</a>. Error conditions that may arise during reading of a <a>ByteStream</a> will be handled by a reject callback set to the promise returned by the read() method. An example will be illustrative.
		</p>

		<p>
			In the example below, different code blocks handle progress, error, and success conditions.
			The example demonstrates how to read a chunk of data from a <a>ByteStream</a> using <code>read</code>. The <a>ByteStream</a> may of come from a <a href="#producers	">producer</a> such as <code>XMLHttpRequest</code>. Additionally, it demonstrates how to read a stream until an EOF is encountered.
		</p>

		<pre class="example">// Read up to 1024 bytes from the ReadableByteStream
stream.readEncoding = "UTF-8";
stream.readType = "arraybuffer";
var result = stream.read(1024);
if (result.eof) {
  // EOF reached
} else if (result.size == 0) {
  result.data.then(
    function (result) {
      processData(result.data);
      ...
    },
    function (error) {
      // Handle error
    }
  );
} else {
  // Done synchronously
  processData(result.data);
  ...
}</pre>

		<pre class="example">// Read data from the ReadableByteStream repeatedly
function readUntilEof() {
  while (true) {
    var result = stream.read();
    if (result.eof) {
      return;
    } else if (result.size == 0) {
      result.data.then(
        function (result) {
          processData(result.data);

          if (!result.eof) {
            readUntilEof();
          }
        },
        function (error) {
          // Handle error
        }
      );
    } else {
      processData(result.data);
    }
  }
}

readUntilEof();</pre>

		<p>
			In the example below, different code blocks handle progress, error, and success conditions.
			The example below demonstrates how to obtain a <a>ReadableByteStream</a> from <a>XMLHttpRequest</a> to begin playing a large video in <code>readystate</code> LOADING.
			The example takes the <a>ReadableByteStream</a> from a <a href="#producers">producer</a>, <a>XMLHttpRequest</a>, and gives to a <a href="#consumers">consumer</a>, the video tag.
		</p>

		<pre class="example">function handler() {
  if(this.readyState == this.LOADING) {
    var theStream = this.response;
    var streamURL = URL.createObjectURL(theStream);
    document.getElementById("myVideoTag").src = streamURL;
  }
}

var client = new XMLHttpRequest();
client.onreadystatechange = handler;
client.setRequestHeader('customHeader', 'value');
client.setRequestHeader('customHeader2', 'value2');
client.open("GET", "myvideo.h264");
client.responseType = "stream";
client.send();</pre>

		<p>
			In addition to the <a>ReadableByteStream</a> interface, this specification introduces an interface called <a>WritableByteStream</a> for data consuming APIs.
			The <a>WritableByteStream</a> interface provides a <code>write()</code> method which allows applications to write data to the data consuming API as listed in <a href="#consumers">consumer</a>.
			<code>write()</code> supports writing bytes represented as a <a>Blob</a>, <a>ArrayBuffer</a>, or <a>DOMString</a>.
		</p>
		<p>
			The example below demonstrates how to use <code>write()</code> to load a Stream into the audio tag, whose data could be processed and built dynamically at read time.
		</p>

		<pre class="example">var stream = new ByteStream("audio/mp3");

function writeData() {
  // Do work to create more data to place into the stream
  var data = generateMusic();

  // If we have no more data to process and place in the stream, we close
  if (moreData == null){
    stream.writeClose();
  } else{
    // Wait until write() completes.
    stream.write(data).then(
      function () {
        writeData();
      },
      function (error) {
        // Handle error
      }
    );
  }
}

var streamURL = URL.createObjectURL(theStream);
document.getElementById('audioTag').src = streamURL;

writeData();</pre>

		<p>
			If you have a producer code which should do work only when pulled, <code>waitForWritable()</code> should be used to wait for pull event.
		</p>

		<pre class="example">function poll() {
  stream.waitForWritable().then(
    function (pulledAmount) {
      stream.write(generateRandomBytes(pulledAmount));
      poll();
    }
  );
}

poll();</pre>
	</section>

	<section class="section" id="data_source">
		<h2>Data source model</h2>

		<p>
			Interfaces introduced in the later section provides simple and convenient way to consume data.
			They connect a raw sequence of bytes to with JavaScript world using Promises and method invocations.
			Before describing them, here, we'll describe the model of data source which provides to be consumed via the interfaces.
			To allow multiple consumers, we should do some reference counting on the data source.
			The algorithm below allows for it.
		</p>

		<pre>
function DataSource() {
  this.data = new Deque([]);
  // SortedList keeps elements sorted in accending order based
  // on value.
  this.sortedReaderPositions = new SortedMap([{key: 0, value: 0}]);
  // Holds the number of bytes consumed and freed from data.
  this.bytesConsumed = 0;
}

DataSource.prototype.read = function(long readerId, unsigned long long amount) {
  // Calculate offset in data.
  var startOffset = this.sortedReaderPositions.getAndRemove(readerId) - bytesConsumed;

  var result = this.data.slice(startOffset, amount);

  this.sortedReaderPosisions.put(readerId, end);

  // Free bytes consumed by all readers.
  var newBytesConsumed = this.sortedReaderPosisions.lastValue();
  this.data.pop(newBytesConsumed - this.bytesConsumed);
  this.bytesConsumed = newBytesConsumed;

  return result;
};</pre>

    <p>
			When <a href="#widl-ReadableByteStream-fork-ReadableByteStream">fork()</a> is called, a new reader is registered to the original <a>ReadableByteStream</a>'s data source and the new <a>ReadableByteStream</a> uses read() method to fetch data from it.
    </p>
	</section>

	<section class="section" id="writableByteStream">
		<h2>WritableByteStream interface</h2>

		<p>
			The WritableByteStream interface defines a protocol for APIs that consume byte stream:
			<ol>
				<li>How to receive byte stream</li>
				<li>How to notify the writer of completion of writing</li>
				<li>How much data it can accept currently</li>
			</ol>

			By returning a Promise and delaying fulfillment of it, the WritableByteStream realizes flow control.
		</p>

		<dl class="idl" title="interface WritableByteStream">
			<dt>attribute DOMString writeEncoding</dt>
			<dd>
				<p>
					Specifies a <a>DOMString</a> that represents the label of an encoding [[!EncodingDetermination]].
					If set, it will be used as part of the encoding determination used when processing a <code>write()</code> method call.
					It will return the label last set, or the empty <a>DOMString</a> if never set.
				</p>

				<p>
					This parameter is not designed to be specified as an argument of write() since it's not likely to be changed frequently.
				</p>
			</dd>

			<dt>Promise&amp;lt;unsigned long long&gt; write()</dt>
			<dd>
				<p>
					This method writes the specified <var>data</var> to the WritableByteStream.
					If <var>data</var> is a <a>DOMString</a>, it will be encoded using writeEncoding.
					The returned <a>Promise</a> will be fulfilled with the number of bytes written to the WritableByteStream when all of <var>data</var> is successfully written.
					The returned <a>Promise</a> will be rejected on any error.
					Incomplete write() operations are queued in the WritableByteStream.
				</p>

				<dl class="parameters">
					<dt>(DOMString or ArrayBufferView or Blob) data</dt>
					<dd>Data to write.</dd>
				</dl>
			</dd>

			<dt>Promise&amp;lt;unsigned long long&gt; waitForWritable()</dt>
			<dd>
				<p>
					This method waits until the WritableByteStream becomes able to accept any non-zero amount of data.
					The returned Promise will be fulfilled with the number of bytes the WritableByteStream can accept.
				</p>
			</dd>

			<dt>void writeClose()</dt>
			<dd>
				<p>
					This method tells the WritableByteStream that no more data will be written to it.
					Once writeClose() has been called on a WritableByteStream, any more method call must not be made on the WritableByteStream.
				</p>
			</dd>
		</dl>
	</section>

	<section class="section" id="readableByteStream">
		<h2>ReadableByteStream interface</h2>

		<p>
			The ReadableByteStream interface defines a protocol for APIs that produces byte stream:
			<ol>
				<li>How to receive a read request from the reader and output byte stream.</li>
				<li>How to transfer bulk data to other <a>WritableByteStream</a> (by <code>pipe()</code> method)</li>
				<li>How to mirror data to multiple destination <a>WritableByteStream</a>s (by <code>fork()</code> and <code>pipe()</code> method)</li>
			</ol>

			By returning a <a>Promise</a> and delaying fulfillment of it, the ReadableByteStream realizes asynchronous data consumption.
		</p>

		<p>
			ReadableByteStream interface has an associated internal <a href="#h2_data_source">data source</a>.
			ReadableByteStream is given a reader ID for the <a href="#h2_data_source">data source</a> on construction.
		</p>

		<p>
			ReadableByteStream interface has associated integer variables <dfn>outputLimit</dfn>, <dfn>readExactPullAmount</dfn>, <dfn>pipePullAmount</dfn> and <dfn>lastFulfillAmount</dfn>.
		</p>
		<p>
			<a>outputLimit</a> is determined by <code>max(max(<a href="#widl-ReadableByteStream-pullAmount">pullAmount</a>, <a>readExactPullAmount</a>, <a>pipePullAmount</a>) - <a>lastFulfillAmount</a>, 0)</code>.
			Interpretation of <a>outputLimit</a> is up to each implementation of ReadableByteStream.

			<section class="note">
				outputLimit typically limits the size of buffer.
			</section>
		</p>
		<p>
			<a>readExactPullAmount</a> is initialized to 0 by default on construction.
		</p>
		<p>
			<a>pipePullAmount</a> is initialized to 0 by default on construction.
		</p>
		<p>
			<a>lastFulfillAmount</a> is initialized to 0 by default on construction.
			lastFulfillAmount is set to the number of bytes used to fulfill the returned Promise of <code>read()</code> and <code>readExact()</code> method call on fulfillment, or bytes being transferred to the destination WritableByteStream by <code>pipe()</code> but not yet acknowledged.
			lastFulfillAmount is set to 0 at the beginning of <code>read()</code> and <code>readExact()</code> method call, or bytes trasnferred by <code>pipe()</code> are acknowledged.

			<section class="note">
				Using this attribute, ReadableByteStream delays replenishment of outputLimit until the next read/pipe operation.
			</section>
		</p>

		<dl class="idl" title="interface ReadableByteStream">
			<dt>attribute ByteStreamReadType readType</dt>
			<dd>
				<p>
					Specifies as what type data will be read from the ReadableByteStream by a <code>read()</code> and <code>readExact()</code> method call.
					This attribute can be set to the empty <a>DOMString</a> (default), "<code>arraybuffer</code>", "<code>blob</code>", "<code>text</code>" or "<code>none</code>".
				</p>
			</dd>

			<dt>attribute DOMString readEncoding</dt>
			<dd>
				<p>
					Specifies a <a>DOMString</a> that represents the label of an encoding [[!EncodingDetermination]].
					If set, it will be used as part of the encoding determination used when processing a <code>read()</code> method call.
				</p>

				<section class="note">
					This parameter is not designed to be specified as an argument of <code>read()</code> since it's not likely to be changed frequently.
				</section>
			</dd>

			<dt>attribute unsigned long long pullAmount</dt>
			<dd>
				<p>
					This attribute is used to compute <a>outputLimit</a> to tell the ReadableByteStream a hint how many bytes the reader can consume currently.
					Each implementation of ReadableByteStream must define how to determine the initial value of pullAmount and set it to the value on construction.
				</p>

				<section class="note">
					This flow control functionality is provided as a separated attribute rather than as an argument of the read() method based on assumption that most people don't change the value so frequently.
				</section>
			</dd>

			<dt>Promise&amp;lt;ByteStreamReadResult&gt; readExact()</dt>
			<dd>
				<p>
					<ol>
						<li>If <a href="#widl-ReadableByteStream-readType">readType</a> is not any of "<code>arraybuffer</code>", "<code>blob</code>" and "<code>none</code>", throw a "<code><a>SyntaxError</a></code>"</li>
						<li>Let <var>latchedType</var> be the current value of <a href="#widl-ReadableByteStream-readType">readType</a> attribute</li>
						<li>Let <var>latchedEncoding</var> be the current value of <a href="#widl-ReadableByteStream-readEncoding">readEncoding</a> attribute</li>
						<li>Set <a>readExactPullAmount</a> to <var>size</var></li>
						<li>Set <a>lastFulfillAmount</a> to 0</li>
						<li>Let <var>readPromise</var> be a <a>Promise</a></li>
						<li>Return <var>readPromise</var> and continue to process the steps in this algorithm</li>
						<li>Wait until bytes of the number specified by <var>size</var> argument become available for read or <a>the EOF is reached</a></li>
						<li>If <a>the EOF is reached</a>, let <var>readBytes</var> be all bytes until EOF if <a>the EOF is reached</a>. Otherwise, let <var>readBytes</var> be the first <var>size</var> bytes of readable bytes</li>
						<li>Let <var>bytesConsumed</var> be the size of <var>readBytes</var></li>
						<li>Set <a>lastFulfillAmount</a> to <var>bytesConsumed</var></li>
						<li>Set <a>readExactPullAmount</a> to 0</li>
						<li>Advance the read cursor of this ReadableByteStream on the associated internal data source by <var>bytesConsumed</var></li>
						<li>Let <var>result</var> be a <a>ByteStreamReadResult</a></li>
						<li>
							If <var>latchedType</var> is "<code>none</code>", set <a href="#widl-ByteStreamReadResult-data">data</a> attribute of <var>result</var> to <var>readData</var> to <code>undefined</code>.
							Otherwise, run these steps.
							<ol>
								<li>Let <var>readData</var> be the result of converting <var>readBytes</var> into an object of the type specified by <var>latchedType</var></li>
								<li>Set <a href="#widl-ByteStreamReadResult-data">data</a> attribute of <var>result</var> to <var>readData</var></li>
							</ol>
						</li>
						<li>Set <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute of <var>result</var> to <code>true</code> if <a>the EOF is reached</a></li>
						<li>Set <a href="#widl-ByteStreamReadResult-size">size</a> attribute of <var>result</var> to <var>bytesConsumed</var></li>
						<li>Fulfill <var>readPromise</var> with <var>result</var></li>
					</ol>
				</p>

				<dl class="parameters">
					<dt>[Clamp] unsigned long long size</dt>
					<dd>Number of bytes to read.</dd>
				</dl>

				<section class="note">
					This method is useful if
					<ol>
						<li>You don't want to get notified of new data unless bytes of the specified number become available</li>
						<li>You don't want to get result fragmented into multiple objects</li>
					</ol>
				</section>
			</dd>

			<dt>Promise&amp;lt;ByteStreamReadResult&gt; read()</dt>
			<dd>
				<p>
					This method reads data from the ReadableByteStream.
					The returned Promise will be fulfilled when any non-empty result can be read or EOF is reached.
				</p>

				<p>
					Another <code>read()</code>, <code>readExact()</code>, <code>pipe()</code> or <code>fork()</code> method call must not be made until this <code>read()</code> completes.
				</p>

				<p>
					This method must run the steps below:

					<ol>
						<li>Let <var>latchedType</var> be the current value of <a href="#widl-ReadableByteStream-readType">readType</a> attribute and <var>latchedEncoding</var> be the current value of <a href="#widl-ReadableByteStream-readEncoding">readEncoding</a> attribute</li>
						<li>Set <a>lastFulfillAmount</a> to 0</li>
						<li>Let <var>readPromise</var> be a <a>Promise</a></li>
						<li>Return <var>readPromise</var> and continue to process the steps in this algorithm</li>
						<li>
							<dl class="switch">
								<dt>If <var>latchedType</var> is "<code>text</code>"</dt>
								<dd>
									<ol>
										<li>
											Wait until bytes become available for read where the first <a href="#widl-ReadableByteStream-pullAmount">pullAmount</a> or less bytes can be converted into a non-empty <a>DOMString</a> when decoded using <var>latchedEncoding</var>, or <a>the EOF is reached</a>
										</li>
										<li>
											If <a>the EOF is reached</a>, let <var>readBytes</var> be all bytes until EOF.
											Otherwise, let <var>readBytes</var> be the bytes which can be converted into a non-empty <a>DOMString</a>.
										</li>
										<li>Let <var>readData</var> be the result of decoding the bytes using <var>latchedEncoding</var></li>
									</ol>
								</dd>
								<dt>Otherwise</dt>
								<dd>
									<ol>
										<li>Wait until non-zero number of bytes become avalable for read, or <a>the EOF is reached</a></li>
										<li>
											If <a>the EOF is reached</a>, let <var>readBytes</var> be all bytes until EOF.
											Otherwise, let <var>readBytes</var> be the readable bytes
										</li>
										<li>Let <var>readData</var> be an object of the type specified by <var>latchedType</var> which represents <var>readBytes</var></li>
									</ol>
								</dd>
							</dl>
						</li>
						<li>Let <var>bytesConsumed</var> be the size of <var>readBytes</var></li>
						<li>Set <a>lastFulfillAmount</a> to <var>bytesConsumed</var></li>
						<li>Advance the read cursor of this ReadableByteStream on the associated internal data source by <var>bytesConsumed</var></li>
						<li>Let <var>result</var> be a <a>ByteStreamReadResult</a>.</li>
						<li>Set <a href="#widl-ByteStreamReadResult-data">data</a> attribute of <var>result</var> to <var>readData</var></li>
						<li>Set <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute of <var>result</var> to <code>true</code> if <a>the EOF is reached</a></li>
						<li>Set <a href="#widl-ByteStreamReadResult-size">size</a> attribute of <var>result</var> to <var>bytesConsumed</var>.</li>
						<li>Fulfill <var>readPromise</var> with <var>result</var></li>
					</ol>
				</p>

				<section class="note">
					This method is useful if
					<ol>
						<li>You don't care in what size and as how many fragments the data will be received</li>
						<li>You want to limit the number of bytes read for flow control</li>
					</ol>
				</section>
			</dd>

			<dt>ByteStreamReadResult pipe()</dt>
			<dd>
				<p>
					This method bulk transfers bytes from the ReadableByteStream to a <a>WritableByteStream</a>.
				</p>

				<section class="note">
					Fulfillment of the returned Promise doesn't necessarily mean that the data transferred to the destination <a>WritableByteStream</a> has been successfully read from it.
				</section>

				<p>
					Another <code>read()</code>, <code>readExact()</code>, <code>pipe()</code> or <code>fork()</code> method call must not be made until this <code>pipe()</code> completes.
				</p>

				<p>
					This method must run the steps below:

					<ol>
						<li>Let <var>bytesRemaining</var> be <var>size</var> argument if specified</li>
						<li>Set <a>lastFulfillAmount</a> to 0</li>
						<li>Let <var>pipePromise</var> be a <a>Promise</a></li>
						<li>Return <var>pipePromise</var> and continue to process the steps in this algorithm</li>
						<li>Let <var>totalBytesTransferred</var> be 0</li>
						<li>
							Repeat the steps below:
							<ol>
								<li>Wait until non-zero number of bytes can be written to destination</li>
								<li>Let <var>bytesWritable</var> be the number and update <a>pipePullAmount</a> to <code>min(<var>bytesRemaining</var>, <var>bytesWritable</var>)</code></li>
								<li>Set <a>lastFulfillAmount</a> to 0</li>
								<li>Wait until non-zero number of bytes become avalable for read, or <a>the EOF is reached</a></li>
								<li>Transfer the bytes up to <a>pipePullAmount</a> to destination</li>
								<li>Let <var>bytesTransferred</var> be the size of the transferred bytes</li>
								<li>Update <var>totalBytesTransferred</var> to <var>totalBytesTransferred</var> + <var>bytesTransferred</var></li>
								<li>Update <var>bytesRemaining</var> to <var>bytesRemaining</var> - <var>bytesTransferred</var></li>
								<li>Set <a>lastFulfillAmount</a> to <var>bytesTransferred</var></li>
								<li>Advance the read cursor of this ReadableByteStream on the associated internal data source by <var>bytesTransferred</var></li>
								<li>Break when <a>the EOF is reached</a> or <var>bytesRemaining</var> is 0</li>
							</ol>
						</li>

						<li>Set <a>pipePullAmount</a> to 0</li>
						<li>Let <var>result</var> be a <a>ByteStreamReadResult</a></li>
						<li>Set <a href="#widl-ByteStreamReadResult-data">data</a> attribute of <var>result</var> to <var>readData</var> to <code>undefined</code>.
						<li>Set <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute of <var>result</var> to <code>true</code> if <a>the EOF is reached</a></li>
						<li>Set <a href="#widl-ByteStreamReadResult-size">size</a> attribute of <var>result</var> to <var>totalBytesTransferred</var></li>
						<li>
							Fulfill <var>readPromise</var> with <var>result</var>
							<section class="note">
								At his point, <a>lastFulfillAmount</a> is not yet reset
							</section>
						</li>
					</ol>
				</p>

				<dl class="parameters">
					<dt>WritableByteStream destination</dt>
					<dd>Destination <a>WritableByteStream</a>.</dd>
					<dt>optional [Clamp] unsigned long long size</dt>
					<dd>Number of bytes to transfer.</dd>
				</dl>
			</dd>

			<dt>ReadableByteStream fork()</dt>
			<dd>
				<p>
					This method creates a clone of the ReadableByteStream which refers to the same internal <a href="#h2_data_source">data source</a>.
					The internal data source of the original ReadableByteStream will be range reference counted so that a range in the original data source is freed only when all the ReadableByteStreams sharing the data source finish consuming it.
				</p>
			</dd>

			<dt>void readClose()</dt>
			<dd>
				<p>
					This method tells the ReadableByteStream that no more data will be read from it.
				</p>
			</dd>
		</dl>
	</section>

	<section class="section">
		<h2>ByteStreamReadResult Interface</h2>

		<p>
			This interface represents the result of methods on <a>ReadableByteStream</a>.
		</p>

		<dl class="idl" title="interface ByteStreamReadResult">
			<dt>readonly attribute boolean eof</dt>
			<dd>specifies if the given read resulted in an EOF</dd>
			<dt>readonly attribute any data</dt>
			<dd>The resulting contents of the read request possibly a <a>Promise</a> when it's done asynchronously</dd>
			<dt>readonly attribute unsigned long long size</dt>
			<dd>The size, in bytes, of the data read</dd>
		</dl>
	</section>

	<section class="section">
		<h2>ByteStreamReadType enum</h2>

		<p>
			Data can be read as various data types from <a>ReadableByteStream</a>.
			This enum defines <a>DOMString</a> values to specify the data types.
		</p>

		<dl class="idl" title="enum ByteStreamReadType">
			<dt>blob</dt>
			<dd>Read operations should return data as a <a>Blob</a></dd>
			<dt>arraybuffer</dt>
			<dd>Read operations should return data as an <a>ArrayBuffer</a></dd>
			<dt>text</dt>
			<dd>Read operations should return data as a <a>DOMString</a></dd>
			<dt>none</dt>
			<dd>
				Read operations should return nothing.
				Useful for seeking data by skipping some amount of data.
				User agents may implement some optimization for "<code>none</code>" type read for example omitting internal data transfer.
			</dd>
		</dl>
	</section>

	<section class="section" id="streams">
		<h2>ByteStream</h2>

		<p>
			This section introduces the <code>ByteStream</code> interface, as well as accompanying interfaces required as part of the <a>ByteStream</a> implementation.
			This includes a constructor to build a <a>ByteStream</a> object, implementation of <a>WritableByteStream</a> and <a>ReadableByteStream</a> and the type attribute.
		</p>

		<section class="section" id="stream-interface">
			<h2>ByteStream Interface</h2>

			<p>
				This interface represents a sequence of bytes which can be read only once over time and to which we can push data.
				Contents of a ByteStream can be stored in memory or backed by slower devices such as a hard disk.
			</p>

			<p>
				A ByteStream is an object that:
				<ul>
					<li>Has a content type. The <a href="#widl-ByteStream-type">type</a> attribute represents it.</li>
					<li>Has unspecified length.</li>
					<li>Data is read first in, first out</li>
					<li>Once data is read from it, the data is removed and can no longer be re-read</li>
				</ul>
			</p>

			<p>
				A ByteStream object inherits the <a>WritableByteStream</a> and <a>ReadableByteStream</a> interface and satisfies requirements for them.
			</p>

			<p>
				A ByteStream has an associated integer value called <dfn>capacity</dfn>.
			</p>

			<p>
				<dfn>temporaryCapacity</dfn> of a ByteStream is defined as <code>max(<a>pullAmount</a>, <a>capacity</a>)</code> where <dfn>pullAmount</dfn> is <var>size</var> argument of pending <code>read()</code>, <code>readExact()</code> or <code>pipe()</code> method call on the ByteStream.
				This value limits the number of bytes buffered in the ByteStream.
			</p>

			<p>
				A ByteStream holds a sequence of bytes possibly terminated by a terminator.
				<dfn id="write-to-stream">Writing bytes to a ByteStream</dfn> means appending the bytes to the sequence.
				<dfn id="terminate-stream">Terminating a ByteStream</dfn> means appending a terminator to the sequence.
				<dfn id="read-from-stream">Reading bytes from a ByteStream</dfn> pops bytes from the head of the sequence.
				If a terminator is encountered while reading bytes from a Stream, it is said <dfn id="eof-reached">the EOF is reached</dfn>.
				This sequence is internal, so scripts cannot access it directly.
			</p>

			<p>
				When <var>N</var> bytes of data are written to the sequence, it consumes <var>N</var> from <a>temporaryCapacity</a>.
				When <var>N</var> bytes of data are read from the sequence, it frees <var>N</var> to <a>temporaryCapacity</a>.
			</p>

			<p>
				A ByteStream can accept up to <a>temporaryCapacity</a> bytes of data.
				Overflowing write() requests are queued as well as other <a>WritableByteStream</a>s.
				This queue is internal, so scripts cannot access it directly.
			</p>

			<dl class="idl" title="interface ByteStream : ReadableByteStream, WritableByteStream">
				<dt>Constructor()</dt>
				<dd>
					Constructs a <a>ByteStream</a> and sets the <a href="#widl-ByteStream-type">type</a> to the specified value.
					<dl class="parameters">
						<dt>in unsigned long long capacity</dt>
						<dd>
							Specifies the initial value of <a>capacity</a>.
						</dd>
						<dt>in optional DOMString type</dt>
						<dd>
							Specifies the MIME type [[!RFC2046]] of the <a>ByteStream</a>.
						</dd>
					</dl>
				</dd>

				<dt>attribute DOMString writeEncoding</dt>
				<dd></dd>

				<dt>Promise&amp;lt;unsigned long long&gt; write()</dt>
				<dd>
					<p>
						The user agent must run the steps below (unless otherwise indicated):
					</p>

					<p>
						NEEDS TO BE UPDATED

						<s>
						<ol>
							<li>
								If the <a>ByteStream</a> has been neutered, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
							</li>
							<li>
								If the <a>write closed flag</a> is set, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
							</li>
							<li>
								Let <var>writePromise</var> be a new promise.
							</li>
							<li>
								Return <var>writePromise</var>, but continue to process the steps in this algorithm.
							</li>
							<li>
								If no <a>window</a> is available, queue the write() operation to <a>write pending queue</a> and wait for <a>window</a> becomes available.

								Execute the rules below, depending on the type of <code>data</code>:

								<dl class="switch">
									<dt><code>ArrayBufferView</code></dt>
									<dd>
										Let <code>rawData</code> be the raw data represented by the <code>Blob</code> object.
									</dd>
									<dt><code>Blob</code></dt>
									<dd>
										Let <code>rawData</code> be the data stored in the section of the buffer described by the <code>ArrayBuffer</code> object that the <code>ArrayBufferView</code> object references.
									</dd>
									<dt><code>DOMString</code></dt>
									<dd>
										Let <code>rawData</code> be the result of <a href="http://encoding.spec.whatwg.org/#encode">encoding</a> <code>data</code> to binary data using the encoding determined by the [[!EncodingDetermination]].
									</dd>
								</dl>
							</li>
							<li>
								<a href="#write-to-stream">Write <code>rawData</code> to the Stream</a>.
							</li>
							<li>
								If an error has occurred during the write, neuter the <a>ByteStream</a>, let <code>exception</code> be an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and run <code>Reject(<code>writePromise</code>, <code>exception</code>)</code> as specified in the promises spec and terminate this algorithm.
							<li>
								Once all bytes are written, remove the write() from <a>write pending queue</a> and run <code>Resolve(<code>writePromise</code>, <code>undefined</code>)</code> as specified in the promises spec.
								Implementations may delay this step if appropriate.
							</li>
						</ol></s>
					</p>
					<p>
						Note that completion of write() doesn't necessarily mean that the data written to the Stream has been successfully read.
					</p>
					<dl class="parameters">
						<dt>(DOMString or ArrayBufferView or Blob) data</dt>
						<dd>Data to write or available <a>window</a> size.</dd>
					</dl>
				</dd>

				<dt>Promise&amp;lt;unsigned long long&gt; waitForWritable()</dt>
				<dd></dd>

				<dt>void writeClose()</dt>
				<dd>
					<p>
						When all data has been read from the <a>ByteStream</a> on which writeClose() has been called, i.e. <a href="#eof-reached">EOF is reached</a>, it resolves the Promise returned by read() with a <a>ByteStreamReadResult</a> with the <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute set to true.
						The user agent must run the steps below:
					</p>

					<p>
						NEEDS TO BE UPDATED
					</p>

					<s>
					<ol>
						<li>
							If the <a>ByteStream</a> has been neutered, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
						</li>
						<li>
							If the <a>write closed flag</a> is set, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
						</li>
						<li>
							Set the <a>write closed flag</a>.
						</li>
						<li>
							Let <var>closePromise</var> be a new <a>Promise</a> and return it but keep processing the following algorithm.
						</li>
						<li>
							Wait until <a>write pending queue</a> becomes empty.
						</li>
						<li>
							<a href="#terminate-stream">Terminate the Stream</a>.
						</li>
						<li>
							If an error has occurred during writing a stream termination, neuter the <a>ByteStream</a> and terminate these steps.
						</li>
					</ol></s>
				</dd>

				<dt>readonly attribute DOMString type</dt>
				<dd>
					Returns the ASCII-encoded string in lower case representing the media type of the <code>Stream</code>,
					expressed as an RFC2046 MIME type [[!RFC2046]].
					Conforming user agents SHOULD return the MIME type of the <code>Stream</code>, if it is known.
					If conforming user agents cannot determine the media type of the <code>Stream</code>, they MUST return the empty string.
					A string is a valid MIME type if it matches the media-type token defined in section 3.7 "Media Types" of RFC 2616 [[!HTTP11]].
				</dd>

				<dt>attribute <a>ByteStreamReadType</a> readType</dt>
				<dd></dd>

				<dt>attribute DOMString readEncoding</dt>
				<dd></dd>

				<dt>ByteStreamReadResult readExact()</dt>
				<dd>
					<dl class="parameters">
						<dt>[Clamp] unsigned long long size</dt>
						<dd>Number of bytes to read.</dd>
					</dl>
				</dd>

				<dt>ByteStreamReadResult read()</dt>
				<dd>
					<p>
						NEEDS TO BE UPDATED
					</p>

					<s>
					<p>
						This method reads data from the <a>ByteStream</a>.
						This method takes an optional <var>size</var> argument which represents the number of bytes to be read.
						Another read() or pipe() call must not be made until the returned Promise is resolved or rejected.
						The user agent must run the steps below (unless otherwise indicated):
					</p>

					<ol>
						<li>
							If the <a>ByteStream</a> has been neutered, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
						</li>
						<li>
							If the <a>read pending flag</a> is set, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
						</li>
						<li>
							If <code>size</code> is specified but is 0, throw a "<code><a>SyntaxError</a></code>" [[!DOM4]] exception and terminate these steps.
						</li>
						<li>
							Set the <a>read pending flag</a>.
						</li>
						<li>
							Let <code>readPromise</code> be a new promise.
						</li>
						<li>
							Return <code>readPromise</code>, but continue to process the steps in this algorithm.
						</li>
						<li>
							If <code>size</code> is specified, <a href="#read-from-stream">read data from the Stream</a> until <code>size</code> bytes are read.
						</li>
						<li>
							Otherwise, <a href="#read-from-stream">read data from the Stream</a> until any non-zero bytes are read.
						</li>
						<li>
							If an error has occurred during reading, neuter the <a>ByteStream</a>, let <code>exception</code> be an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and run <code>Reject(<code>readPromise</code>, <code>exception</code>)</code> as specified in the promises spec and terminate these steps.
						</li>
						<li>
							Let <code>result</code> be a newly created <a>ByteStreamReadResult</a>.
						</li>
						<li>
							If EOF is reached, set the <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute of <code>result</code> to true.
						</li>
						<li>
							Otherwise, set the <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute of <code>result</code> to false.
						</li>
						<li>
							Set the <a href="#widl-ByteStreamReadResult-eof">data</a> attribute of <code>result</code> to the result of executing the steps below.
							<dl class="switch">
								<dt>If <a href="#widl-ByteStream-readType">readType</a> is the empty string or "<code title>text</code>"</dt>
								<dd>
									<ol>
										<li>
											If readEncoding is not null, let <var>charset</var> be <code>readEncoding</code>.
										</li>
										<li>
											Otherwise, let <var>charset</var> be utf-8.
										</li>
										<li>
											Let <code>result</code> be result of <a href="http://encoding.spec.whatwg.org/#decode">decoding</a> the data read using fallback encoding <var>charset</var>.
										</li>
									</ol>
								</dd>
								<dt>If <a href="#widl-ByteStream-readType">readType</a> is the empty string or "<code title>blob</code>"</dt>
								<dd>
									Let <code>result</code> be a blob created from the read data.
								</dd>
								<dt>If <a href="#widl-ByteStream-readType">readType</a> is the empty string or "<code title>arraybuffer</code>"</dt>
								<dd>
									Let <code>result</code> be an array buffer created from the read data.
								</dd>
							</dl>
						</li>
						<li>
							Unset the <a>read pending flag</a> and run <code>Resolve(<code>readPromise</code>, <code>result</code>)</code> as specified in the promises spec.
						</li>
					</ol>
					</s>

					<dl class="parameters">
						<dt>optional [Clamp] unsigned long long size</dt>
						<dd>Number of bytes to read.</dd>
					</dl>
				</dd>

				<dt>ByteStreamReadResult pipe()</dt>
				<dd>
					<p>
						NEEDS TO BE UPDATED
					</p>

					<s>
					<p>
						This method transfers data from the <a>ByteStream</a> to another Stream.
						This method takes a <code>destinations</code> and optionally a <code>size</code>.
						Another read(), skip() or pipe() call must not be made until the returned Promise is resolved or rejected.
						Resolution of the returned Promise doesn't necessarily mean that the data transferred to the destination Stream has been successfully read from the Stream.
						The user agent must run the steps below:

						<ol>
							<li>
								If the <a>ByteStream</a> has been neutered, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
							</li>
							<li>
								If the <a>read pending flag</a> is set, throw an "<code><a>InvalidStateError</a></code>" [[!DOM4]] exception and terminate these steps.
							</li>
							<li>
								If <code>size</code> is specified but is 0, throw a "<code><a>SyntaxError</a></code>" [[!DOM4]] exception and terminate these steps.
							</li>
							<li>
								If <code>destinations</code> is a <a>ByteStream</a>, let <code>destinations</code> instead be an array consisting of just that <a>ByteStream</a>.
							</li>
							<li>
								Set the <a>read pending flag</a>.
							</li>
							<li>
								Let <code>readPromise</code> be a new promise.
							</li>
							<li>
								Return the pipe() method with <code>readPromise</code>, but continue to process the steps in this algorithm.
							</li>
							<li>
								If <code>size</code> is specified, <a href="#read-from-stream">read data from the stream</a> until <code>size</code> bytes are read.
							</li>
							<li>
								Otherwise, <a href="#read-from-stream">read data from the Stream</a> until <a href="#eof-reached">EOF is reached</a>.
							</li>
							<li>
								As read data becomes available, <a href="#write-to-stream">write newly read data to <code>destinations</code></a>.
							</li>
							<li>
								If any error has occurred during reading or writing to <code>destinations</code>, neuter the <a>ByteStream</a>, let <code>exception</code> be an "<code><a>InvalidStateError</a></code>" exception and run <code>Reject(<code>readPromise</code>, <code>exception</code>)</code> as specified in the promises spec and terminate these steps.
							</li>
							<li>
								Once read and write are both completed for all destination streams, run the following algorithm:
								<ol>
									<li>
										Let <code>result</code> be a newly created <a>ByteStreamReadResult</a> object.
									</li>
									<li>
										If <a href="#eof-reached">EOF is reached</a>, set <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute of <code>result</code> to true.
									</li>
									<li>
										Otherwise, set <a href="#widl-ByteStreamReadResult-eof">eof</a> attribute of <code>result</code> set to false.
									</li>
									<li>
										Set <a href="#widl-ByteStreamReadResult-size">size</a> attribute of <code>result</code> to the total size of the read data.
									</li>
									<li>
										Unset the <a>read pending flag</a> and run <code>Resolve(<code>readPromise</code>, <code>result</code>)</code> as specified in the promises spec.
									</li>
								</ol>
							</li>
						</ol>
						<dl class="parameters">
							<dt>in WritableByteStream destination</dt>
							<dd>Destination <a>WritableByteStream</a>.</dd>
							<dt>optional [Clamp] unsigned long long size</dt>
							<dd>Number of bytes to transfer.</dd>
						</dl>
					</p></s>
				</dd>

				<dt>ReadableByteStream fork()</dt>
				<dd></dd>

				<dt>void readClose()</dt>
				<dd></dd>
			</dl>
		</section>

		<section class="section" id="error-uris_for_streams">
			<h3>URIs for Stream</h3>
			<p>
				To reference a <a>ByteStream</a>, <a href="http://dev.w3.org/2006/webapi/FileAPI/#url">the same URI used</a> for <code>Blobs</code> and <code>Files</code> in
				<a href="http://dev.w3.org/2006/webapi/FileAPI/#url">6.7. A URI for Blob and File reference</a> of
				the File API specification should be used. [[!FILE-API]]
				The definitions of <strong>Origin</strong>, <strong>Lifetime</strong>, <strong>Referencing</strong>, and <strong>Dereferencing</strong> of a <code>Blob</code> should be applied to a <a>ByteStream</a>.
			</p>

			<section class="section" id="creating-revoking-streamuri">
				<h4>Creating and Revoking a Stream URI</h4>
				<p>
					A <dfn id="stream-uri">Stream URI</dfn> is a <code>Blob URI</code> that is referencing a <a>ByteStream</a>.
					These URIs are created and revoked using methods exposed on the URL object,
					as defined in <a href="http://dev.w3.org/2006/webapi/FileAPI/#creating-revoking">6.7.5. Creating and Revoking a Blob URI</a>
					of the File API specification. [[!FILE-API]]
				</p>
				<p>
					<a href="http://dev.w3.org/2006/webapi/FileAPI/#dfn-createObjectURL">URL.createObjectURL</a>
					and <a href="http://dev.w3.org/2006/webapi/FileAPI/#dfn-revokeObjectURL">URL.revokeObjectURL</a>
					should both be extended as follows:
				</p>
				<dl class="idl" title="interface URL">
					<dt>static DOMString? createObjectURL(in (Blob or ReadableByteStream) object)</dt>
					<dd>
						<p>
							The extension onto <code>createObjectURL</code> should have the following steps added.
						</p>
						<p>
							Returns a unique Blob URL each time it is called on a valid <code>object</code> argument, which is a non-null <a>ByteStream</a> in scope of the global object's URL property from which this static method is called. This method must act as follows:
							<ol>
								<li>
									If called with a <code>Stream</code> argument that is NOT valid, then user agents must return null.
								</li>
								<li>
									If called with a valid <code>Stream</code> argument,
									user agents must run the following sub-steps:
									<ol>
										<li>
											If the <a>read pending flag</a> of the <a>ByteStream</a> is set, return null.
										</li>
										<li>
											Set the <a>read pending flag</a> of the <a>ByteStream</a>.
										</li>
										<li>
											Return a unique <code>Blob URI</code> that can be used to dereference the <code>stream</code> argument.
										</li>
										<li>
											Add an entry to the Blob URL Store for this Blob URL.
										</li>
									</ol>
								</li>
							</ol>
						</p>
					</dd>

					<dt>static DOMString? createFor(in (Blob or ReadableByteStream) object)</dt>
					<dd>
						<p>
							The extension onto <code>createFor</code> should have the following steps added.
						</p>
						<p>
							Returns a unique Blob URL each time it is called on a valid <code>object</code> argument, which is a non-null <a>ByteStream</a> in scope of the global object's URL property from which this static method is called. Blob URLs created with this method are said to be auto-revoking since user-agents are responsible for the revocation of Blob URLs created with this method, subject to the lifetime stipulation for Blob URLs. This method must act as follows:
							<ol>
								<li>
									If called with a <code>Stream</code> argument that is NOT valid, then user agents must return null.
								</li>
								<li>
									If called with a valid <code>Stream</code> argument,
									user agents must run the following sub-steps:
									<ol>
										<li>
											If the <a>read pending flag</a> of the <a>ByteStream</a> is set, return null.
										</li>
										<li>
											Set the <a>read pending flag</a> of the <a>ByteStream</a>.
										</li>
										<li>
											Return a unique <code>Blob URI</code> that can be used to dereference the <code>stream</code> argument.
										</li>
										<li>
											Add an entry to the Blob URL Store for this Blob URL.
										</li>
										<li>
											Add an entry in the Revocation List for this Blob URL.
										</li>
									</ol>
								</li>
							</ol>
						</p>
					</dd>

					<dt>static void revokeObjectURL(in DOMString url)</dt>
					<dd>
						<p>
							The extension onto <code>revokeObjectURL</code> should have the following steps added.
						</p>
						<ol>
							<li>
								If the URL refers to a <code>Blob</code> or <code>Stream</code> that is both
								valid and in the same origin of the global object’s <code>URL</code> property on which this static method was called,
								user agents MUST return a 404 response code when the URL is dereferenced.
							</li>
							<li>
								If the URL refers to a <code>Blob</code> or <code>Stream</code> that is <strong>not</strong> valid
								or if the value provided for the URL argument is not a <code>Blob URI</code>
								or if the URL argument refers to a <code>Blob</code> or <code>Stream</code> that is <strong>not</strong> in the same origin
								as the global object’s <code>URL</code> property, this method call does nothing.
								User agents MAY display a message on their error console.
							</li>
						</ol>
					</dd>
				</dl>
			</section>
		</section>
	</section>

	<section class="section" id="producers-consumers">
		<h2>Stream Consumers and Producers</h2>
		<p>
			Streams can be both produced and consumed by various APIs. APIs which create streams are identified as producers, and ones which read and act on a stream are known as consumers. This section identifies some of the APIs where Streams may be produced and consumed.
			<section class="note">The list of producers and consumers below is not an exhaustive list. It is placed here as informative for the time being.</section>
		</p>
		<section class="section" id="consumers">
			<h2>Stream Consumers</h2>
			<p>This section outlines APIs which can consume a Stream object</p>
			<ul>
				<li>WebAudio</li>
				<li>MediaSourceExtensions</li>
				<li>WebCrypt</li>
				<li>TextEncoder</li>
				<li>TextDecoder</li>
				<li>WebSockets</li>
			</ul>
		</section>

		<section class="section" id="producers">
			<h2>Stream Producers</h2>
			<p>This section outlines APIs which can produce a Stream object</p>
			<ul>
				<li>XMLHttpRequest</li>
				<li>FileReader</li>
				<li>Media Capture</li>
				<li>Media Recording API</li>
				<li>IndexedDB</li>
				<li>WebCrypt</li>
				<li>TextEncoder</li>
				<li>TextDecoder</li>
				<li>WebSockets</li>
				<li>EventSource</li>
			</ul>
		</section>
	</section>

	<section class="section" id="security">
		<h2>Security Considerations</h2>
		<p>
			A <a>ByteStream</a> should have the same security considerations as a <code>Blob</code>.
			This is outlined in <a href="http://dev.w3.org/2006/webapi/FileAPI/#security-discussion">6.8. Security Considerations</a>
			of the File API specification. [[!FILE-API]]
			Because a <a>ByteStream</a> uses a <code>Blob URI</code>, cross origin requests on a <a>ByteStream</a> will not be supported.
		</p>
	</section>

	<section class="section" id="XMLHttpRequest">
		<h2>Extension of XMLHttpRequest</h2>
		<p>
			This specification proposes an extension to <code>XMLHttpRequest</code> [[!XMLHTTPREQUEST2]] to add support for <a>ByteStream</a>. This section is temporary and is meant to provide a recommendation for how <a>ByteStream</a> should be incorporated into <code>XMLHttpRequest</code>.
			This will extend <code>XMLHttpRequest</code> to allow for receiving and uploading of a <a>ByteStream</a>.
			One such scenario is providing access to data during <a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#dom-xmlhttprequest-readystate"><code>readyState</code></a> 3 (LOADING).
			The sections below document in detail what extensions must be done to <code>XMLHttpRequest</code> to support <a>ByteStream</a>.
		</p>

		<section class="section" title="addition-of-stream-response-entity">
			<h3>Addition of stream response entity body</h3>
			<p>
				<a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#response-entity-body-0">The section named "Response Entity Body"</a>
				in XMLHttpRequest specification [[!XMLHTTPREQUEST2]] should have the following additions:
			</p>
			<p>
				The <dfn id="stream-response-entity">stream response entity body</dfn> is either a <a>ByteStream</a> representing the <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#response-entity-body">response entity body</a> or null.
				If the <a href="#stream-response-entity">stream response entity body</a> is null, let it be the return value of the following algorithm:
			</p>
			<ol>
				<li>
					If the <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#response-entity-body">response entity body</a> is null,
					return an empty <a>ByteStream</a> object.
				</li>
				<li>
					Return a <a>ByteStream</a> object representing the <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#response-entity-body">response entity body</a>.
				</li>
			</ol>
		</section>

		<section class="section" title="addition-of-stream">
			<h3>Addition of "<code>stream</code>" responseType</h3>
			<p>
				A new value for the <code>responseType</code> attribute "<code>stream</code>" should be introduced.
			</p>
			<p>
				In the IDL list in <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#interface-xmlhttprequest">the section named "Interface XMLHttpRequest"</a> in XMLHttpRequest specification [[!XMLHTTPREQUEST2]], the definition of <code>XMLHttpRequestResponseType</code> enum should now read:
				<pre>
enum XMLHttpRequestResponseType {
  "",
  "arraybuffer",
  "blob",
  "stream",
  "document",
  "json",
  "text"
}</pre>
			</p>
		</section>

		<section class="section" title="modification-on-response-algorithm">
			<h3>Modification on the <code>response</code> attribute</h3>
			<p>
				The algorithm of the <code>response</code> attribute should be modified to handle the new <code>responseType</code> value "<code>stream</code>".
				A Stream is binary data obtained sequentially over time.
				Given this, a <a>ByteStream</a> should be accessible in <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-readystate"><code>readyState</code></a> 3 (LOADING).
			</p>
			<p>
				<a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#the-response-attribute">The section named "The response attribute"</a> in XMLHttpRequest specification [[!XMLHTTPREQUEST2]] should now read:
			</p>
			<p>
				The <code>response</code> attribute must return the result of running these steps:
			</p>
			<dl class="switch">
				<dt>If <a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#dom-xmlhttprequest-responsetype"><code>responseType</code></a> is the empty string or "<code>text</code>"</dt>
				<dd>
					The same as the original XMLHttpRequest specification.
				</dd>
				<dt>If <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-responsetype"><code>responseType</code></a> is "<code>stream</code>"</dt>
				<dd>
					<ol>
						<li>
							If the state is not <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-loading">LOADING</a> or
							<a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#dom-xmlhttprequest-done">DONE</a>, return null.
						</li>
						<li>
							If the <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#error-flag">error flag</a> is set, return null.
						</li>
						<li>
							Return the <a href="#stream-response-entity">stream response entity body</a>.
						</li>
					</ol>
				</dd>
				<dt>Otherwise</dt>
				<dd>
					The same as the original XMLHttpRequest specification.
				</dd>
			</dl>
		</section>

		<section class="section" id="modification-on-send-algorithm">
			<h3>send()</h3>
			<p>
				The switch in otherwise case of step 4 of
				<a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#the-send()-method">The section named "The <code>send()</code> method"</a>
				in XMLHttpRequest specification [[!XMLHTTPREQUEST2]] should have the following additions:
			</p>
			<dl class="switch">
				<dt><a>ByteStream</a></dt>
				<dd>
					<p>
						If the object's <a href="#widl-ByteStream-type">type</a> attribute is not the empty string let <var>mime type</var> be its value.
					</p>
					<p>
						Set the <a>read pending flag</a> for the stream.
					</p>
					<p>
						Let the <a href="https://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html#request-entity-body">request entity body</a> be the raw data represented by <var>data</var>.
					</p>
					<p>Once the read is completed for the request, call <a href="#widl-ByteStream-close-void">writeClose()</a> on the stream</p>
				</dd>
			</dl>
		</section>
	</section>

	<section class="section" id="terminology">
		<h2>Terminology</h2>

		<p>
			<dfn>ArrayBuffer</dfn> and <dfn>ArrayBufferView</dfn> are defined in <a href="http://www.khronos.org/registry/typedarray/specs/latest/">Typed Array specification</a>.
		</p>

		<p>
			<dfn>Blob</dfn> is defined in <a href="http://dev.w3.org/2006/webapi/FileAPI/">File API specification</a>.
		</p>

		<p>
			<dfn>Promise</dfn> is defined in <a href="https://github.com/domenic/promises-unwrapping/blob/master/README.md">Promise Objects specification</a>.
		</p>

		<p>
			<dfn>DOMString</dfn> is defined in <a href="http://www.w3.org/TR/DOM-Level-3-Core/core.html">DOM Level 3 Core specification</a>.
		</p>

		<p>
			<dfn>XMLHttpRequest</dfn> is defined in [[!XMLHTTPREQUEST2]].
		</p>

		<p>
			<dfn>InvalidStateError</dfn> is defined in <a href="https://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#invalidstateerror">DOM4 specification</a>.
			<dfn>SyntaxError</dfn> is defined in <a href="https://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#syntaxerror">DOM4 specification</a>.
		</p>
	</section>

	<section class="section" id="requirements">
		<h2>Requirements and Use Cases</h2>
		<p>
			The <a>ByteStream</a> type allows for completion of several end-to-end experiences. This section covers what the requirements are for this API, and
			illustrates some use cases.
		</p>
		<ul>
			<li>
				Begin loading a video through <code>XMLHttpRequest</code> in <code>readyState</code> LOADING
				<p>
					Videos can typically be large files that may take a long time to download, and require authentication or certain headers to access.
					For certain video formats, an application can begin playing the video once the first chunks of data are available, and would not need to wait for the entire video to download.
				</p>
			</li>
			<li>
				Begin processing the data of a <a>ByteStream</a> as it is being read via <code>XMLHttpRequest</code>
				<p>
					If a file format is understood, then an application can make sense of the data as it being made available. For example, a given
					file may be very large and the application wants to begin processing the data immediately, rather than having to wait for full download of the file.
				</p>
			</li>
			<li>
				Upload of dynamic runtime data using <a>ByteStream</a> and <code>XMLHttpRequest</code>
				<p>
					There are situations where an application may have data to upload once the application is processing. This could involve processing
					of data an application wants to upload as it is being created. One such case is the upload of GPS coordinates within an application. The
					coordiantes may constantly change, and the application wants to upload the data as it being collected.
				</p>
			</li>
			<li>
				Media streaming scenarios using <a>ByteStream</a> and <code>XMLHttpRequest</code>
				<p>
					Media streaming scenarios require the ability to quickly receive data over the network and connect it to a media element. An application can successfully accomplish this by receiving a Stream in <code>readyState</code> LOADING and assign it to a media element. This helps avoid the application from having to buffer the data prior to assigning it to a media element.
				</p>
			</li>
		</ul>
	</section>

	<section class=appendix>
		<h2>Acknowledgements</h2>
		<p>
			Thanks to Eliot Graff for editorial assistance.
			Special thanks to the W3C.
			The editor would like to thank
			Anne van Kesteren,
			Austin William Wright,
			Aymeric Vitte,
			Domenic Denicola,
			Elliott Sprehn,
			Isaac Schlueter,
			Jonas Sicking,
			Kenneth Russell,
			Kinuko Yasuda,
			Michael Davidson,
			Taiju Tsuiki,
			Yusuke Suzuki,
			Yutaka Hirano,
			Adrian Bateman
			for their contributions to this specification.
		</p>
	</section>

</body>
</html>
